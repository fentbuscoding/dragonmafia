////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------------------------------------------------------
// FSR 3.0 FLATTENED IMPLEMENTATION
//------------------------------------------------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

"#ifndef FFX_FSR3_FLATTENED\n"
"#define FFX_FSR3_FLATTENED\n"

// FSR3 specific constants
"#define FSR3_WORKGROUP_SIZE 8\n"
"#define FSR3_PASS_UPSCALE 1\n"
"#define FSR3_PASS_TEMPORAL 2\n"

// FSR3 Upscale constants setup
"void Fsr3UpscaleCon(\n"
"    out vec4 con0,\n"
"    out vec4 con1,\n"
"    out vec4 con2,\n"
"    out vec4 con3,\n"
"    out vec4 con4,\n"
"    float inputSizeX,\n"
"    float inputSizeY,\n"
"    float inputImageSizeX,\n"
"    float inputImageSizeY,\n"
"    float outputSizeX,\n"
"    float outputSizeY)\n"
"{\n"
"    // Calculate scaling factors\n"
"    con0.x = outputSizeX / inputSizeX;\n"
"    con0.y = outputSizeY / inputSizeY;\n"
"    con0.z = 0.5 * con0.x - 0.5;\n"
"    con0.w = 0.5 * con0.y - 0.5;\n"
"    \n"
"    con1.x = 1.0 / inputImageSizeX;\n"
"    con1.y = 1.0 / inputImageSizeY;\n"
"    con1.z = 0.5 * con1.x;\n"
"    con1.w = 0.5 * con1.y;\n"
"    \n"
"    // Temporal configuration\n"
"    con2 = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    con3 = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    con4 = vec4(0.0, 0.0, 0.0, 0.0);\n"
"}\n"

// FSR3 Upscaling function
"void Fsr3Upscale(\n"
"    inout vec3 pix,\n"
"    ivec2 ip,\n"
"    vec4 con0,\n"
"    vec4 con1,\n"
"    vec4 con2,\n"
"    vec4 con3,\n"
"    vec4 con4)\n"
"{\n"
"    // Convert to floating point position\n"
"    vec2 pp = vec2(ip) * con0.xy + con0.zw;\n"
"    vec2 fp = floor(pp);\n"
"    pp -= fp;\n"
"    \n"
"    // Calculate sample positions\n"
"    vec2 p0 = fp * con1.xy + con1.zw;\n"
"    vec2 p1 = p0 + vec2(con1.x, 0.0);\n"
"    vec2 p2 = p0 + vec2(0.0, con1.y);\n"
"    vec2 p3 = p0 + vec2(con1.x, con1.y);\n"
"    \n"
"    // Sample input texture (placeholder - actual implementation would sample from input)\n"
"    // This would normally use texture sampling functions\n"
"    vec3 c00 = vec3(1.0, 1.0, 1.0);\n"
"    vec3 c10 = vec3(1.0, 1.0, 1.0);\n"
"    vec3 c01 = vec3(1.0, 1.0, 1.0);\n"
"    vec3 c11 = vec3(1.0, 1.0, 1.0);\n"
"    \n"
"    // Bilinear interpolation\n"
"    vec3 c0 = mix(c00, c10, pp.x);\n"
"    vec3 c1 = mix(c01, c11, pp.x);\n"
"    pix = mix(c0, c1, pp.y);\n"
"    \n"
"    // Apply sharpening (simplified RCAS-like)\n"
"    pix *= 1.1;\n"
"    pix = min(pix, vec3(1.0));\n"
"}\n"

// FSR3 Temporal upscaling with history
"void Fsr3TemporalUpscale(\n"
"    inout vec3 pix,\n"
"    ivec2 ip,\n"
"    vec4 con0,\n"
"    vec4 con1,\n"
"    vec4 con2,\n"
"    vec4 con3,\n"
"    vec4 con4)\n"
"{\n"
"    // Enhanced temporal upscaling with motion vectors\n"
"    // This is a placeholder for the full temporal implementation\n"
"    Fsr3Upscale(pix, ip, con0, con1, con2, con3, con4);\n"
"    \n"
"    // Additional temporal processing would go here\n"
"    // - Motion vector sampling\n"
"    // - History blending\n"
"    // - Temporal stability\n"
"}\n"

"#endif // FFX_FSR3_FLATTENED\n"